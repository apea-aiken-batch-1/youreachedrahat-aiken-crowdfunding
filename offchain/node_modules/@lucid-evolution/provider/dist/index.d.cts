import { Provider, ProtocolParameters, Address, Credential, UTxO, Unit, OutRef, RewardAddress, Delegation, DatumHash, Datum, TxHash, Transaction, EvalRedeemer, Assets, OutputData, UnixTime, Lovelace } from '@lucid-evolution/core-types';
import * as effect_Cause from 'effect/Cause';
import * as effect_Types from 'effect/Types';

declare class Blockfrost implements Provider {
    url: string;
    projectId: string;
    constructor(url: string, projectId?: string);
    getProtocolParameters(): Promise<ProtocolParameters>;
    getUtxos(addressOrCredential: Address | Credential): Promise<UTxO[]>;
    getUtxosWithUnit(addressOrCredential: Address | Credential, unit: Unit): Promise<UTxO[]>;
    getUtxoByUnit(unit: Unit): Promise<UTxO>;
    getUtxosByOutRef(outRefs: OutRef[]): Promise<UTxO[]>;
    getDelegation(rewardAddress: RewardAddress): Promise<Delegation>;
    getDatum(datumHash: DatumHash): Promise<Datum>;
    awaitTx(txHash: TxHash, checkInterval?: number): Promise<boolean>;
    submitTx(tx: Transaction): Promise<TxHash>;
    private blockfrostUtxosToUtxos;
    evaluateTx(tx: Transaction, additionalUTxOs?: UTxO[]): Promise<EvalRedeemer[]>;
}

declare const KupmiosError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "KupmiosError";
} & Readonly<A>;
declare class KupmiosError extends KupmiosError_base<{
    cause?: unknown;
}> {
    get message(): string;
}
declare class Kupmios implements Provider {
    kupoUrl: string;
    ogmiosUrl: string;
    /**
     * @param kupoUrl: http(s)://localhost:1442
     * @param ogmiosUrl: http(s)://localhost:1337
     */
    constructor(kupoUrl: string, ogmiosUrl: string);
    getProtocolParameters(): Promise<ProtocolParameters>;
    getUtxos(addressOrCredential: Address | Credential): Promise<UTxO[]>;
    getUtxosWithUnit(addressOrCredential: Address | Credential, unit: Unit): Promise<UTxO[]>;
    getUtxoByUnit(unit: Unit): Promise<UTxO>;
    getUtxosByOutRef(outRefs: Array<OutRef>): Promise<UTxO[]>;
    getDelegation(rewardAddress: RewardAddress): Promise<Delegation>;
    getDatum(datumHash: DatumHash): Promise<Datum>;
    awaitTx(txHash: TxHash, checkInterval?: number): Promise<boolean>;
    submitTx(cbor: Transaction): Promise<TxHash>;
    evaluateTx(tx: Transaction, additionalUTxOs?: UTxO[]): Promise<EvalRedeemer[]>;
}

/** Concatentation of txHash + outputIndex */
type FlatOutRef = string;
type EmulatorAccount = {
    seedPhrase: string;
    address: Address;
    assets: Assets;
    outputData?: OutputData;
    privateKey: string;
};
declare function generateEmulatorAccountFrommPrivateKey(assets: Assets): Promise<EmulatorAccount>;
declare function generateEmulatorAccount(assets: Assets): EmulatorAccount;
declare class Emulator implements Provider {
    ledger: Record<FlatOutRef, {
        utxo: UTxO;
        spent: boolean;
    }>;
    mempool: Record<FlatOutRef, {
        utxo: UTxO;
        spent: boolean;
    }>;
    /**
     * Only stake key registrations/delegations and rewards are tracked.
     * Other certificates are not tracked.
     */
    chain: Record<RewardAddress, {
        registeredStake: boolean;
        delegation: Delegation;
    }>;
    blockHeight: number;
    slot: number;
    time: UnixTime;
    protocolParameters: ProtocolParameters;
    datumTable: Record<DatumHash, Datum>;
    constructor(accounts: EmulatorAccount[], protocolParameters?: ProtocolParameters);
    now(): UnixTime;
    awaitSlot(length?: number): void;
    awaitBlock(height?: number): void;
    getUtxos(addressOrCredential: Address | Credential): Promise<UTxO[]>;
    getProtocolParameters(): Promise<ProtocolParameters>;
    getDatum(datumHash: DatumHash): Promise<Datum>;
    getUtxosWithUnit(addressOrCredential: Address | Credential, unit: Unit): Promise<UTxO[]>;
    getUtxosByOutRef(outRefs: OutRef[]): Promise<UTxO[]>;
    getUtxoByUnit(unit: string): Promise<UTxO>;
    getDelegation(rewardAddress: RewardAddress): Promise<Delegation>;
    awaitTx(txHash: string): Promise<boolean>;
    /**
     * Emulates the behaviour of the reward distribution at epoch boundaries.
     * Stake keys need to be registered and delegated like on a real chain in order to receive rewards.
     */
    distributeRewards(rewards: Lovelace): void;
    submitTx(tx: Transaction): Promise<TxHash>;
    evaluateTx(tx: Transaction, additionalUTxOs?: UTxO[]): Promise<EvalRedeemer[]>;
    log(): void;
}

type MaestroSupportedNetworks = "Mainnet" | "Preprod" | "Preview";
interface MaestroConfig {
    network: MaestroSupportedNetworks;
    apiKey: string;
    turboSubmit?: boolean;
}
declare class Maestro implements Provider {
    url: string;
    apiKey: string;
    turboSubmit: boolean;
    constructor({ network, apiKey, turboSubmit }: MaestroConfig);
    getProtocolParameters(): Promise<ProtocolParameters>;
    private getUtxosInternal;
    getUtxos(addressOrCredential: Address | Credential): Promise<UTxO[]>;
    getUtxosWithUnit(addressOrCredential: Address | Credential, unit: Unit): Promise<UTxO[]>;
    getUtxoByUnit(unit: Unit): Promise<UTxO>;
    getUtxosByOutRef(outRefs: OutRef[]): Promise<UTxO[]>;
    getDelegation(rewardAddress: RewardAddress): Promise<Delegation>;
    getDatum(datumHash: DatumHash): Promise<Datum>;
    awaitTx(txHash: TxHash, checkInterval?: number): Promise<boolean>;
    submitTx(tx: Transaction): Promise<TxHash>;
    private commonHeaders;
    private requireAmountsAsStrings;
    private maestroUtxoToUtxo;
    private getAllPagesData;
    evaluateTx(tx: Transaction, additionalUTxOs?: UTxO[]): Promise<EvalRedeemer[]>;
}

declare const KoiosError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "KoiosError";
} & Readonly<A>;
declare class KoiosError extends KoiosError_base<{
    cause?: unknown;
}> {
    get message(): string;
}
/**
 * @description This class supports Koios API v1.2a
 */
declare class Koios implements Provider {
    private readonly baseUrl;
    constructor(baseUrl: string);
    getProtocolParameters(): Promise<ProtocolParameters>;
    getUtxos(addressOrCredential: Address | Credential): Promise<UTxO[]>;
    getUtxosWithUnit(addressOrCredential: Address | Credential, unit: Unit): Promise<UTxO[]>;
    getUtxoByUnit(unit: Unit): Promise<UTxO>;
    getUtxosByOutRef(outRefs: OutRef[]): Promise<UTxO[]>;
    getDelegation(rewardAddress: RewardAddress): Promise<Delegation>;
    getDatum(datumHash: DatumHash): Promise<Datum>;
    awaitTx(txHash: TxHash, checkInterval?: number): Promise<boolean>;
    submitTx(tx: Transaction): Promise<TxHash>;
    evaluateTx(tx: Transaction, additionalUTxOs?: UTxO[]): Promise<EvalRedeemer[]>;
}

export { Blockfrost, Emulator, type EmulatorAccount, Koios, KoiosError, Kupmios, KupmiosError, Maestro, type MaestroConfig, type MaestroSupportedNetworks, generateEmulatorAccount, generateEmulatorAccountFrommPrivateKey };
