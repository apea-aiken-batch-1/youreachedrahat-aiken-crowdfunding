"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  CML: () => CML,
  ERROR_MESSAGE: () => ERROR_MESSAGE,
  Lucid: () => Lucid,
  RunTimeError: () => RunTimeError,
  TxBuilderError: () => TxBuilderError,
  TxSignerError: () => TxSignerError,
  TxSubmitError: () => TxSubmitError,
  makeReturn: () => makeReturn,
  makeSubmit: () => makeSubmit,
  makeTxBuilder: () => makeTxBuilder,
  makeTxSignBuilder: () => makeTxSignBuilder
});
module.exports = __toCommonJS(src_exports);

// src/core.ts
var import_effect = require("effect");
var CML = __toESM(require("@anastasia-labs/cardano-multiplatform-lib-nodejs"), 1);
var makeReturn = (program) => {
  return {
    unsafeRun: () => import_effect.Effect.runPromise(program),
    safeRun: () => import_effect.Effect.runPromise(import_effect.Effect.either(program)),
    program: () => program
  };
};

// src/lucid-evolution/utils.ts
var import_utils = require("@lucid-evolution/utils");
var import_plutus = require("@lucid-evolution/plutus");
var datumOf = async (provider, utxo, type) => {
  if (!utxo.datum) {
    if (!utxo.datumHash) {
      throw new Error("This UTxO does not have a datum hash.");
    }
    utxo.datum = await provider.getDatum(utxo.datumHash);
  }
  return import_plutus.Data.from(utxo.datum, type);
};
var metadataOf = async (provider, unit) => {
  const { policyId, name, label } = (0, import_utils.fromUnit)(unit);
  switch (label) {
    case 222:
    case 333:
    case 444: {
      const utxo = await provider.getUtxoByUnit((0, import_utils.toUnit)(policyId, name, 100));
      const metadata = await datumOf(provider, utxo);
      return import_plutus.Data.toJson(metadata.fields[0]);
    }
    default:
      throw new Error("No variant matched.");
  }
};

// src/lucid-evolution/LucidEvolution.ts
var import_utils14 = require("@lucid-evolution/utils");

// src/tx-builder/internal/Collect.ts
var import_effect4 = require("effect");
var import_plutus2 = require("@lucid-evolution/plutus");
var import_utils3 = require("@lucid-evolution/utils");

// src/Errors.ts
var import_effect2 = require("effect");
var ERROR_MESSAGE = {
  MULTIPLE_POLICIES: "MULTIPLE_POLICIES: Only one policy id allowed. You can chain multiple mintAssets functions together if you need to mint assets with different policy ids. ",
  EMPTY_UTXO: "EMPTY_UTXO: UTxO array is empty. If a Tx has been recently submitted, consider waiting for chain sync",
  MISSING_WALLET: "MISSING_WALLET: please ensure that your wallet has been properly configured and initialized",
  MISSING_REDEEMER: "MISSING_REDEEMER: redeemer can not be undefined",
  DATUM_NOT_SET: "DATUM_NOT_SET: Script inputs becomes unspendable without datum.",
  EMPTY_ASSETS: "EMPTY_ASSETS: Attempting to pay to an address with an empty assets object",
  MISSING_REWARD_TYPE: "MISSING_REWARD_TYPE: Address type must be Reward type.",
  MISSING_STAKE_CREDENTIAL: "MISSING_STAKE_CREDENTIAL: Address does not contain stake credential",
  MISSING_PAYMENT_CREDENTIAL: "MISSING_PAYMENT_CREDENTIAL: Address does not contain payment credential",
  INVALID_METADATA: "INVALID_METADATA: metadata is invalid",
  SCRIPT_CREDENTIAL_NOT_ALLOWED: "SCRIPT_CREDENTIAL_NOT_ALLOWED: Only verification key credential is allowed",
  INVALID_SCRIPT: "INVALID_SCRIPT: Script is invalid",
  EXPECTED_KEY_HASH: "EXPECTED_KEY_HASH",
  INVALID_NETWORK: (address, actualNetworkId, network) => `Invalid address: ${address}, Expected address with network id ${actualNetworkId}, current network ${network}`,
  MISSING_SCRIPT: (hash) => `MISSING_SCRIPT: Script not found when building transaction, consider using attach modules. script_hash: ${hash}`,
  MISSING_POLICY: (policyId) => `MISSING_POLICY: No policy found, policy_id: ${policyId}`
};
var TxBuilderError = class extends import_effect2.Data.TaggedError("TxBuilderError") {
  get message() {
    return `${this.cause}`;
  }
};
var TxSignerError = class extends import_effect2.Data.TaggedError("TxSignerError") {
  get message() {
    return `${this.cause}`;
  }
};
var TxSubmitError = class extends import_effect2.Data.TaggedError("TxSubmitError") {
  get message() {
    return `${this.cause}`;
  }
};
var RunTimeError = class extends import_effect2.Data.TaggedError("RunTimeError") {
  get message() {
    return `${this.cause}`;
  }
};

// src/tx-builder/internal/Collect.ts
var CML3 = __toESM(require("@anastasia-labs/cardano-multiplatform-lib-nodejs"), 1);

// src/tx-builder/internal/TxUtils.ts
var CML2 = __toESM(require("@anastasia-labs/cardano-multiplatform-lib-nodejs"), 1);
var import_effect3 = require("effect");
var import_utils2 = require("@lucid-evolution/utils");
var txBuilderError = (cause) => new TxBuilderError({ cause: `{ TxBuilderError : ${cause} }` });
var toCMLAddress = (address, lucidConfig) => import_effect3.Effect.gen(function* ($) {
  const { type } = yield* validateAddressDetails(address, lucidConfig);
  return type === "Byron" ? CML2.ByronAddress.from_base58(address).to_address() : CML2.Address.from_bech32(address);
});
var toV1 = (script) => CML2.PlutusScript.from_v1(CML2.PlutusV1Script.from_cbor_hex(script));
var toV2 = (script) => CML2.PlutusScript.from_v2(CML2.PlutusV2Script.from_cbor_hex(script));
var toV3 = (script) => CML2.PlutusScript.from_v3(CML2.PlutusV3Script.from_cbor_hex(script));
var toPartial = (script, redeemer) => CML2.PartialPlutusWitness.new(
  CML2.PlutusScriptWitness.new_script(script),
  CML2.PlutusData.from_cbor_hex(redeemer)
);
var handleRedeemerBuilder = (config, partialProgram, redeemer) => {
  if (typeof redeemer === "object") {
    config.partialPrograms.set(redeemer, partialProgram);
  } else {
    const program = partialProgram(redeemer);
    config.programs.push(program);
  }
};
var validateAddressDetails = (address, lucidConfig) => import_effect3.Effect.gen(function* ($) {
  const addressDetails = yield* $(
    import_effect3.Effect.try({
      try: () => (0, import_utils2.getAddressDetails)(address),
      catch: (cause) => new TxBuilderError({
        cause
      })
    })
  );
  const actualNetworkId = (0, import_utils2.networkToId)(lucidConfig.network);
  if (addressDetails.networkId !== actualNetworkId)
    yield* new TxBuilderError({
      cause: ERROR_MESSAGE.INVALID_NETWORK(
        address,
        actualNetworkId,
        lucidConfig.network
      )
    });
  return addressDetails;
});
var processCertificate = (stakeCredential, config, buildCert, redeemer) => import_effect3.Effect.gen(function* () {
  switch (stakeCredential.type) {
    case "Key": {
      const credential = CML2.Credential.new_pub_key(
        CML2.Ed25519KeyHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = buildCert(credential);
      config.txBuilder.add_cert(certBuilder.payment_key());
      break;
    }
    case "Script": {
      const credential = CML2.Credential.new_script(
        CML2.ScriptHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = buildCert(credential);
      const script = yield* (0, import_effect3.pipe)(
        import_effect3.Effect.fromNullable(config.scripts.get(stakeCredential.hash)),
        import_effect3.Effect.orElseFail(
          () => txBuilderError(ERROR_MESSAGE.MISSING_SCRIPT(stakeCredential.hash))
        )
      );
      const addPlutusCertificate = (scriptVersion) => {
        return import_effect3.Effect.gen(function* () {
          const red = yield* (0, import_effect3.pipe)(
            import_effect3.Effect.fromNullable(redeemer),
            import_effect3.Effect.orElseFail(
              () => txBuilderError(ERROR_MESSAGE.MISSING_REDEEMER)
            )
          );
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(scriptVersion, red),
              CML2.Ed25519KeyHashList.new()
            )
          );
        });
      };
      switch (script.type) {
        case "PlutusV1":
          yield* addPlutusCertificate(toV1(script.script));
          break;
        case "PlutusV2":
          yield* addPlutusCertificate(toV2(script.script));
          break;
        case "PlutusV3":
          yield* addPlutusCertificate(toV3(script.script));
          break;
        case "Native":
          config.txBuilder.add_cert(
            certBuilder.native_script(
              CML2.NativeScript.from_cbor_hex(script.script),
              CML2.NativeScriptWitnessInfo.assume_signature_count()
            )
          );
          break;
      }
      break;
    }
  }
});
var validateAndGetStakeCredential = (rewardAddress, config) => import_effect3.Effect.gen(function* () {
  const addressDetails = yield* (0, import_effect3.pipe)(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    import_effect3.Effect.andThen(
      (address) => address.type !== "Reward" ? txBuilderError(ERROR_MESSAGE.MISSING_REWARD_TYPE) : import_effect3.Effect.succeed(address)
    )
  );
  const stakeCredential = yield* (0, import_effect3.pipe)(
    import_effect3.Effect.fromNullable(addressDetails.stakeCredential),
    import_effect3.Effect.orElseFail(
      () => txBuilderError(ERROR_MESSAGE.MISSING_STAKE_CREDENTIAL)
    )
  );
  return stakeCredential;
});

// src/tx-builder/internal/Collect.ts
var import_utils4 = require("@lucid-evolution/utils");
var collectError = (cause) => new TxBuilderError({ cause: `{ Collect: ${cause} }` });
var collectFromUTxO = (config, utxos, collectInputs = true) => (redeemer) => import_effect4.Effect.gen(function* ($) {
  if (utxos.length === 0) yield* $(collectError(ERROR_MESSAGE.EMPTY_UTXO));
  for (const utxo of utxos) {
    if (utxo.datumHash && !utxo.datum) {
      const data = yield* $(
        import_effect4.Effect.tryPromise({
          try: () => datumOf(config.lucidConfig.provider, utxo),
          catch: (cause) => collectError({ cause })
        })
      );
      utxo.datum = import_plutus2.Data.to(data);
    }
    const coreUtxo = (0, import_utils3.utxoToCore)(utxo);
    if (collectInputs) config.collectedInputs.push(utxo);
    const input = CML3.SingleInputBuilder.from_transaction_unspent_output(coreUtxo);
    const credential = (0, import_utils4.paymentCredentialOf)(utxo.address);
    if (credential.type == "Script") {
      const script = yield* $(
        import_effect4.Effect.fromNullable(config.scripts.get(credential.hash)),
        import_effect4.Effect.orElseFail(
          () => collectError(
            collectError(ERROR_MESSAGE.MISSING_SCRIPT(credential.hash))
          )
        )
      );
      switch (script.type) {
        case "Native":
          config.txBuilder.add_input(
            input.native_script(
              CML3.NativeScript.from_cbor_hex(script.script),
              CML3.NativeScriptWitnessInfo.assume_signature_count()
            )
          );
          break;
        case "PlutusV1": {
          const red = yield* $(
            import_effect4.Effect.fromNullable(redeemer),
            import_effect4.Effect.orElseFail(
              () => collectError(ERROR_MESSAGE.MISSING_REDEEMER)
            )
          );
          config.txBuilder.add_input(
            input.plutus_script(
              toPartial(toV1(script.script), red),
              CML3.Ed25519KeyHashList.new(),
              CML3.PlutusData.from_cbor_hex(utxo.datum)
            )
          );
          break;
        }
        case "PlutusV2": {
          const v2 = toV2(script.script);
          const red = yield* $(
            import_effect4.Effect.fromNullable(redeemer),
            import_effect4.Effect.orElseFail(
              () => collectError(ERROR_MESSAGE.MISSING_REDEEMER)
            )
          );
          const partial = toPartial(v2, red);
          config.txBuilder.add_input(
            utxo.datum && utxo.datumHash ? input.plutus_script(
              partial,
              CML3.Ed25519KeyHashList.new(),
              CML3.PlutusData.from_cbor_hex(utxo.datum)
            ) : input.plutus_script_inline_datum(
              partial,
              CML3.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV3": {
          const v3 = toV3(script.script);
          const red = yield* $(
            import_effect4.Effect.fromNullable(redeemer),
            import_effect4.Effect.orElseFail(
              () => collectError(ERROR_MESSAGE.MISSING_REDEEMER)
            )
          );
          const partial = toPartial(v3, red);
          config.txBuilder.add_input(
            utxo.datum && utxo.datumHash ? input.plutus_script(
              partial,
              CML3.Ed25519KeyHashList.new(),
              CML3.PlutusData.from_cbor_hex(utxo.datum)
            ) : input.plutus_script_inline_datum(
              partial,
              CML3.Ed25519KeyHashList.new()
            )
          );
          break;
        }
      }
    } else {
      config.txBuilder.add_input(input.payment_key());
    }
  }
});
var collectFromUTxOPartial = (config, utxos, redeemerBuilder) => import_effect4.Effect.gen(function* ($) {
  if (utxos.length === 0) yield* collectError(ERROR_MESSAGE.EMPTY_UTXO);
  if (redeemerBuilder.kind === "self") redeemerBuilder.inputs = utxos;
  for (const utxo of utxos) {
    if (utxo.datumHash && !utxo.datum) {
      const data = yield* $(
        import_effect4.Effect.tryPromise({
          try: () => datumOf(config.lucidConfig.provider, utxo),
          catch: (cause) => collectError({ cause })
        })
      );
      utxo.datum = import_plutus2.Data.to(data);
    }
    config.collectedInputs.push(utxo);
  }
  const partialProgram = collectFromUTxO(config, utxos, false);
  config.partialPrograms.set(redeemerBuilder, partialProgram);
});

// src/tx-builder/internal/Read.ts
var import_effect5 = require("effect");
var import_plutus3 = require("@lucid-evolution/plutus");
var import_utils6 = require("@lucid-evolution/utils");
var readError = (cause) => new TxBuilderError({ cause: `{ Read : ${cause} }` });
var readFrom = (config, utxos) => import_effect5.Effect.gen(function* () {
  if (utxos.length === 0) yield* readError(ERROR_MESSAGE.EMPTY_UTXO);
  for (const utxo of utxos) {
    if (utxo.datumHash) {
      const data = yield* import_effect5.Effect.tryPromise({
        try: () => datumOf(config.lucidConfig.provider, utxo),
        catch: (cause) => readError(cause)
      });
      utxo.datum = import_plutus3.Data.to(data);
    }
    const coreUtxo = (0, import_utils6.utxoToCore)(utxo);
    config.readInputs.push(utxo);
    config.txBuilder.add_reference_input(coreUtxo);
  }
});

// src/tx-builder/internal/Attach.ts
var import_utils8 = require("@lucid-evolution/utils");
var attachScript = ({ type, script }) => {
  switch (type) {
    case "Native":
      return {
        key: CML.NativeScript.from_cbor_hex(script).hash().to_hex(),
        value: { type, script }
      };
    case "PlutusV1":
      return {
        key: CML.PlutusV1Script.from_cbor_hex((0, import_utils8.applyDoubleCborEncoding)(script)).hash().to_hex(),
        value: { type, script: (0, import_utils8.applyDoubleCborEncoding)(script) }
      };
    case "PlutusV2":
      return {
        key: CML.PlutusV2Script.from_cbor_hex((0, import_utils8.applyDoubleCborEncoding)(script)).hash().to_hex(),
        value: { type, script: (0, import_utils8.applyDoubleCborEncoding)(script) }
      };
    case "PlutusV3":
      return {
        key: CML.PlutusV3Script.from_cbor_hex((0, import_utils8.applyDoubleCborEncoding)(script)).hash().to_hex(),
        value: { type, script: (0, import_utils8.applyDoubleCborEncoding)(script) }
      };
    default:
      throw new Error(`Exhaustive check failed: Unhandled case ${type}`);
  }
};
var attachSpendingValidator = (spendingValidator) => attachScript(spendingValidator);
var attachMintingPolicy = (mintingPolicy) => attachScript(mintingPolicy);
var attachCertificateValidator = (certValidator) => attachScript(certValidator);
var attachWithdrawalValidator = (withdrawalValidator) => attachScript(withdrawalValidator);
var attachVoteValidator = (voteValidator) => attachScript(voteValidator);
var attachProposeValidator = (proposeValidator) => attachScript(proposeValidator);

// src/tx-builder/internal/Pay.ts
var import_effect6 = require("effect");
var import_utils9 = require("@lucid-evolution/utils");
var payError = (cause) => new TxBuilderError({ cause: `{ Pay: ${cause} }` });
var payToAddress = (config, address, assets) => import_effect6.Effect.gen(function* () {
  const outputBuilder = CML.TransactionOutputBuilder.new().with_address(yield* toCMLAddress(address, config.lucidConfig)).next();
  if (Object.keys(assets).length == 0)
    yield* payError(ERROR_MESSAGE.EMPTY_ASSETS);
  const value = (0, import_utils9.assetsToValue)(assets);
  let outputResult = outputBuilder.with_asset_and_min_required_coin(
    value.multi_asset(),
    config.lucidConfig.protocolParameters.coinsPerUtxoByte
  ).build();
  const setLovelaces = assets["lovelace"];
  if (setLovelaces) {
    const minLovelace = outputResult.output().amount().coin();
    if (setLovelaces > minLovelace) {
      outputResult = outputBuilder.with_value(value).build();
    }
  }
  config.totalOutputAssets = (0, import_utils9.addAssets)(
    config.totalOutputAssets,
    (0, import_utils9.valueToAssets)(outputResult.output().amount())
  );
  config.payToOutputs = [
    ...config.payToOutputs,
    (0, import_utils9.coreToTxOutput)(outputResult.output())
  ];
  config.txBuilder.add_output(outputResult);
});
var payToAddressWithData = (config, address, outputDatum, assets, scriptRef) => import_effect6.Effect.gen(function* () {
  const outputBuilder = buildBaseOutput(address, outputDatum, scriptRef);
  assets ??= {};
  const value = (0, import_utils9.assetsToValue)(assets);
  let outputResult = outputBuilder.with_asset_and_min_required_coin(
    value.multi_asset(),
    config.lucidConfig.protocolParameters.coinsPerUtxoByte
  ).build();
  const setLovelaces = assets["lovelace"];
  if (setLovelaces) {
    const minLovelace = outputResult.output().amount().coin();
    if (setLovelaces > minLovelace) {
      outputResult = outputBuilder.with_value(value).build();
    }
  }
  config.totalOutputAssets = (0, import_utils9.addAssets)(
    config.totalOutputAssets,
    (0, import_utils9.valueToAssets)(outputResult.output().amount())
  );
  config.payToOutputs = [
    ...config.payToOutputs,
    (0, import_utils9.coreToTxOutput)(outputResult.output())
  ];
  config.txBuilder.add_output(outputResult);
});
var payToContract = (config, address, outputDatum, assets, scriptRef) => import_effect6.Effect.gen(function* () {
  if (!outputDatum.value) yield* payError(ERROR_MESSAGE.DATUM_NOT_SET);
  return yield* payToAddressWithData(
    config,
    address,
    outputDatum,
    assets,
    scriptRef
  );
});
var buildBaseOutput = (address, outputDatum, scriptRef) => {
  let baseBuilder;
  const addressBuilder = CML.TransactionOutputBuilder.new().with_address(
    CML.Address.from_bech32(address)
  );
  switch (outputDatum.kind) {
    case "hash": {
      const datumOption = CML.DatumOption.new_hash(
        CML.DatumHash.from_hex(outputDatum.value)
      );
      baseBuilder = addressBuilder.with_data(datumOption);
      break;
    }
    case "asHash": {
      const plutusData = CML.PlutusData.from_cbor_hex(outputDatum.value);
      baseBuilder = addressBuilder.with_communication_data(plutusData);
      break;
    }
    case "inline": {
      const plutusData = CML.PlutusData.from_cbor_hex(outputDatum.value);
      const datumOption = CML.DatumOption.new_datum(plutusData);
      baseBuilder = addressBuilder.with_data(datumOption);
      break;
    }
    default:
      throw new Error(`Unknown outputDatum: ${outputDatum}`);
  }
  return scriptRef ? baseBuilder.with_reference_script((0, import_utils9.toScriptRef)(scriptRef)).next() : baseBuilder.next();
};

// src/tx-builder/internal/Mint.ts
var import_effect7 = require("effect");
var CML4 = __toESM(require("@anastasia-labs/cardano-multiplatform-lib-nodejs"), 1);
var mintError = (cause) => new TxBuilderError({ cause: `{ Mint: ${cause} }` });
var mintAssets = (config, assets) => (redeemer) => import_effect7.Effect.gen(function* () {
  const units = Object.keys(assets);
  const policyId = units[0].slice(0, 56);
  const mintAssets2 = CML4.MapAssetNameToNonZeroInt64.new();
  for (const unit of units) {
    if (unit.slice(0, 56) !== policyId) {
      yield* mintError(ERROR_MESSAGE.MULTIPLE_POLICIES);
    }
    mintAssets2.insert(CML4.AssetName.from_hex(unit.slice(56)), assets[unit]);
  }
  const mintBuilder = CML4.SingleMintBuilder.new(mintAssets2);
  const policy = yield* (0, import_effect7.pipe)(
    import_effect7.Effect.fromNullable(config.scripts.get(policyId)),
    import_effect7.Effect.orElseFail(
      () => mintError(ERROR_MESSAGE.MISSING_POLICY(policyId))
    )
  );
  switch (policy.type) {
    case "Native":
      config.txBuilder.add_mint(
        mintBuilder.native_script(
          CML4.NativeScript.from_cbor_hex(policy.script),
          CML4.NativeScriptWitnessInfo.assume_signature_count()
        )
      );
      break;
    case "PlutusV1": {
      const red = yield* (0, import_effect7.pipe)(
        import_effect7.Effect.fromNullable(redeemer),
        import_effect7.Effect.orElseFail(() => mintError(ERROR_MESSAGE.MISSING_REDEEMER))
      );
      config.txBuilder.add_mint(
        mintBuilder.plutus_script(
          toPartial(toV1(policy.script), red),
          CML4.Ed25519KeyHashList.new()
        )
      );
      break;
    }
    case "PlutusV2": {
      const red = yield* (0, import_effect7.pipe)(
        import_effect7.Effect.fromNullable(redeemer),
        import_effect7.Effect.orElseFail(() => mintError(ERROR_MESSAGE.MISSING_REDEEMER))
      );
      config.txBuilder.add_mint(
        mintBuilder.plutus_script(
          toPartial(toV2(policy.script), red),
          CML4.Ed25519KeyHashList.new()
        )
      );
      break;
    }
    case "PlutusV3": {
      const red = yield* (0, import_effect7.pipe)(
        import_effect7.Effect.fromNullable(redeemer),
        import_effect7.Effect.orElseFail(() => mintError(ERROR_MESSAGE.MISSING_REDEEMER))
      );
      config.txBuilder.add_mint(
        mintBuilder.plutus_script(
          toPartial(toV3(policy.script), red),
          CML4.Ed25519KeyHashList.new()
        )
      );
      break;
    }
  }
});

// src/tx-builder/internal/Interval.ts
var import_effect8 = require("effect");
var import_utils10 = require("@lucid-evolution/utils");
var validFrom = (config, unixTime) => import_effect8.Effect.gen(function* () {
  const slot = (0, import_utils10.unixTimeToSlot)(config.lucidConfig.network, unixTime);
  config.txBuilder.set_validity_start_interval(BigInt(slot));
});
var validTo = (config, unixTime) => import_effect8.Effect.gen(function* () {
  const slot = (0, import_utils10.unixTimeToSlot)(config.lucidConfig.network, unixTime);
  config.txBuilder.set_ttl(BigInt(slot));
});

// src/tx-builder/internal/Signer.ts
var import_effect9 = require("effect");
var CML5 = __toESM(require("@anastasia-labs/cardano-multiplatform-lib-nodejs"), 1);
var addSignerError = (cause) => new TxBuilderError({ cause: `{ Signer: ${cause} }` });
var addSigner = (config, address) => import_effect9.Effect.gen(function* () {
  const addressDetails = yield* validateAddressDetails(
    address,
    config.lucidConfig
  );
  const credential = addressDetails.type === "Reward" ? yield* (0, import_effect9.pipe)(
    import_effect9.Effect.fromNullable(addressDetails.stakeCredential),
    import_effect9.Effect.orElseFail(
      () => addSignerError(ERROR_MESSAGE.MISSING_STAKE_CREDENTIAL)
    )
  ) : yield* (0, import_effect9.pipe)(
    import_effect9.Effect.fromNullable(addressDetails.paymentCredential),
    import_effect9.Effect.orElseFail(
      () => addSignerError(ERROR_MESSAGE.MISSING_PAYMENT_CREDENTIAL)
    )
  );
  if (credential.type === "Script")
    yield* addSignerError(ERROR_MESSAGE.SCRIPT_CREDENTIAL_NOT_ALLOWED);
  return credential.hash;
}).pipe(import_effect9.Effect.flatMap((keyHash) => addSignerKey(config, keyHash)));
var addSignerKey = (config, keyHash) => import_effect9.Effect.gen(function* () {
  config.txBuilder.add_required_signer(CML5.Ed25519KeyHash.from_hex(keyHash));
});

// src/tx-builder/internal/Stake.ts
var import_effect10 = require("effect");
var CML6 = __toESM(require("@anastasia-labs/cardano-multiplatform-lib-nodejs"), 1);
var stakeError = (cause) => new TxBuilderError({ cause: `{ Stake: ${cause} }` });
var registerStake = (config, rewardAddress) => import_effect10.Effect.gen(function* () {
  const addressDetails = yield* (0, import_effect10.pipe)(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    import_effect10.Effect.andThen(
      (address) => address.type !== "Reward" ? stakeError(ERROR_MESSAGE.MISSING_REWARD_TYPE) : import_effect10.Effect.succeed(address)
    )
  );
  const stakeCredential = yield* (0, import_effect10.pipe)(
    import_effect10.Effect.fromNullable(addressDetails.stakeCredential),
    import_effect10.Effect.orElseFail(
      () => stakeError(ERROR_MESSAGE.MISSING_STAKE_CREDENTIAL)
    )
  );
  const credential = stakeCredential.type === "Key" ? CML6.Credential.new_pub_key(
    CML6.Ed25519KeyHash.from_hex(stakeCredential.hash)
  ) : CML6.Credential.new_script(
    CML6.ScriptHash.from_hex(stakeCredential.hash)
  );
  const certBuilder = CML6.SingleCertificateBuilder.new(
    CML6.Certificate.new_stake_registration(credential)
  );
  config.txBuilder.add_cert(certBuilder.skip_witness());
});
var deRegisterStake = (config, rewardAddress, redeemer) => import_effect10.Effect.gen(function* () {
  const addressDetails = yield* (0, import_effect10.pipe)(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    import_effect10.Effect.andThen(
      (address) => address.type !== "Reward" ? stakeError(ERROR_MESSAGE.MISSING_REWARD_TYPE) : import_effect10.Effect.succeed(address)
    )
  );
  const stakeCredential = yield* (0, import_effect10.pipe)(
    import_effect10.Effect.fromNullable(addressDetails.stakeCredential),
    import_effect10.Effect.orElseFail(
      () => stakeError(ERROR_MESSAGE.MISSING_STAKE_CREDENTIAL)
    )
  );
  const createCertBuilder = (credential, config2) => {
    return CML6.SingleCertificateBuilder.new(
      CML6.Certificate.new_unreg_cert(
        credential,
        config2.lucidConfig.protocolParameters.keyDeposit
      )
    );
  };
  switch (stakeCredential.type) {
    case "Key": {
      const credential = CML6.Credential.new_pub_key(
        CML6.Ed25519KeyHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = createCertBuilder(credential, config);
      config.txBuilder.add_cert(certBuilder.payment_key());
      break;
    }
    case "Script": {
      const credential = CML6.Credential.new_script(
        CML6.ScriptHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = createCertBuilder(credential, config);
      const script = yield* (0, import_effect10.pipe)(
        import_effect10.Effect.fromNullable(config.scripts.get(stakeCredential.hash)),
        import_effect10.Effect.orElseFail(
          () => stakeError(ERROR_MESSAGE.MISSING_SCRIPT(stakeCredential.hash))
        )
      );
      const handleRedeemer = () => (0, import_effect10.pipe)(
        import_effect10.Effect.fromNullable(redeemer),
        import_effect10.Effect.orElseFail(() => stakeError(ERROR_MESSAGE.MISSING_REDEEMER))
      );
      switch (script.type) {
        case "PlutusV1": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV1(script.script), red),
              CML6.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV2": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV2(script.script), red),
              CML6.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV3": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV3(script.script), red),
              CML6.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "Native": {
          config.txBuilder.add_cert(
            certBuilder.native_script(
              CML6.NativeScript.from_cbor_hex(script.script),
              CML6.NativeScriptWitnessInfo.assume_signature_count()
            )
          );
          break;
        }
      }
    }
  }
});
var withdraw = (config, rewardAddress, amount) => (redeemer) => import_effect10.Effect.gen(function* ($) {
  const addressDetails = yield* (0, import_effect10.pipe)(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    import_effect10.Effect.andThen(
      (address) => address.type !== "Reward" ? stakeError(ERROR_MESSAGE.MISSING_REWARD_TYPE) : import_effect10.Effect.succeed(address)
    )
  );
  const withdrawBuilder = yield* (0, import_effect10.pipe)(
    import_effect10.Effect.fromNullable(
      CML6.RewardAddress.from_address(
        CML6.Address.from_bech32(rewardAddress)
      )
    ),
    import_effect10.Effect.orElseFail(
      () => stakeError(ERROR_MESSAGE.MISSING_STAKE_CREDENTIAL)
    ),
    import_effect10.Effect.andThen(
      (address) => CML6.SingleWithdrawalBuilder.new(address, amount)
    )
  );
  const stakeCredential = yield* (0, import_effect10.pipe)(
    import_effect10.Effect.fromNullable(addressDetails.stakeCredential),
    import_effect10.Effect.orElseFail(
      () => stakeError(ERROR_MESSAGE.MISSING_STAKE_CREDENTIAL)
    )
  );
  const handleRedeemer = () => (0, import_effect10.pipe)(
    import_effect10.Effect.fromNullable(redeemer),
    import_effect10.Effect.orElseFail(() => stakeError(ERROR_MESSAGE.MISSING_REDEEMER))
  );
  switch (stakeCredential.type) {
    case "Key": {
      config.txBuilder.add_withdrawal(withdrawBuilder.payment_key());
      break;
    }
    case "Script": {
      const script = yield* (0, import_effect10.pipe)(
        import_effect10.Effect.fromNullable(config.scripts.get(stakeCredential.hash)),
        import_effect10.Effect.orElseFail(
          () => stakeError(ERROR_MESSAGE.MISSING_SCRIPT(stakeCredential.hash))
        )
      );
      switch (script.type) {
        case "PlutusV1": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_withdrawal(
            withdrawBuilder.plutus_script(
              toPartial(toV1(script.script), red),
              CML6.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV2": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_withdrawal(
            withdrawBuilder.plutus_script(
              toPartial(toV2(script.script), red),
              CML6.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV3": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_withdrawal(
            withdrawBuilder.plutus_script(
              toPartial(toV3(script.script), red),
              CML6.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "Native": {
          config.txBuilder.add_withdrawal(
            withdrawBuilder.native_script(
              CML6.NativeScript.from_cbor_hex(script.script),
              CML6.NativeScriptWitnessInfo.assume_signature_count()
            )
          );
          break;
        }
      }
    }
  }
});

// src/tx-builder/internal/Pool.ts
var import_effect11 = require("effect");
var CML7 = __toESM(require("@anastasia-labs/cardano-multiplatform-lib-nodejs"), 1);
var import_core_utils = require("@lucid-evolution/core-utils");
var poolError = (cause) => new TxBuilderError({ cause: `{ Pool : ${cause} }` });
var delegateTo = (config, rewardAddress, poolId, redeemer) => import_effect11.Effect.gen(function* () {
  const addressDetails = yield* (0, import_effect11.pipe)(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    import_effect11.Effect.andThen(
      (address) => address.type !== "Reward" ? poolError(ERROR_MESSAGE.MISSING_REWARD_TYPE) : import_effect11.Effect.succeed(address)
    )
  );
  const stakeCredential = yield* (0, import_effect11.pipe)(
    import_effect11.Effect.fromNullable(addressDetails.stakeCredential),
    import_effect11.Effect.orElseFail(
      () => poolError(ERROR_MESSAGE.MISSING_STAKE_CREDENTIAL)
    )
  );
  switch (stakeCredential.type) {
    case "Key": {
      const credential = CML7.Credential.new_pub_key(
        CML7.Ed25519KeyHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = CML7.SingleCertificateBuilder.new(
        CML7.Certificate.new_stake_delegation(
          credential,
          CML7.Ed25519KeyHash.from_bech32(poolId)
        )
      );
      config.txBuilder.add_cert(certBuilder.payment_key());
      break;
    }
    case "Script": {
      const credential = CML7.Credential.new_script(
        CML7.ScriptHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = CML7.SingleCertificateBuilder.new(
        CML7.Certificate.new_stake_delegation(
          credential,
          CML7.Ed25519KeyHash.from_bech32(poolId)
        )
      );
      const script = yield* (0, import_effect11.pipe)(
        import_effect11.Effect.fromNullable(config.scripts.get(stakeCredential.hash)),
        import_effect11.Effect.orElseFail(
          () => poolError(ERROR_MESSAGE.MISSING_SCRIPT(stakeCredential.hash))
        )
      );
      const handleRedeemer = () => (0, import_effect11.pipe)(
        import_effect11.Effect.fromNullable(redeemer),
        import_effect11.Effect.orElseFail(() => poolError(ERROR_MESSAGE.MISSING_REDEEMER))
      );
      switch (script.type) {
        case "PlutusV1": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV1(script.script), red),
              CML7.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV2": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV2(script.script), red),
              CML7.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV3": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV3(script.script), red),
              CML7.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "Native": {
          config.txBuilder.add_cert(
            certBuilder.native_script(
              CML7.NativeScript.from_cbor_hex(script.script),
              CML7.NativeScriptWitnessInfo.assume_signature_count()
            )
          );
          break;
        }
      }
    }
  }
});

// src/tx-builder/internal/Governance.ts
var import_core_types = require("@lucid-evolution/core-types");
var CML8 = __toESM(require("@anastasia-labs/cardano-multiplatform-lib-nodejs"), 1);
var import_effect12 = require("effect");
var delegateVoteToDRep = (config, rewardAddress, drep, redeemer) => import_effect12.Effect.gen(function* () {
  const stakeCredential = yield* validateAndGetStakeCredential(
    rewardAddress,
    config
  );
  const cmlDRep = (0, import_core_types.toCMLDRep)(drep);
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_vote_deleg_cert(credential, cmlDRep)
  );
  yield* processCertificate(stakeCredential, config, buildCert, redeemer);
});
var delegateVoteToPoolAndDRep = (config, rewardAddress, poolId, drep, redeemer) => import_effect12.Effect.gen(function* () {
  const stakeCredential = yield* validateAndGetStakeCredential(
    rewardAddress,
    config
  );
  const cmlDRep = (0, import_core_types.toCMLDRep)(drep);
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_stake_vote_deleg_cert(
      credential,
      CML8.Ed25519KeyHash.from_bech32(poolId),
      cmlDRep
    )
  );
  yield* processCertificate(stakeCredential, config, buildCert, redeemer);
});
var registerAndDelegateToPool = (config, rewardAddress, poolId, redeemer) => import_effect12.Effect.gen(function* () {
  const stakeCredential = yield* validateAndGetStakeCredential(
    rewardAddress,
    config
  );
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_stake_reg_deleg_cert(
      credential,
      CML8.Ed25519KeyHash.from_bech32(poolId),
      config.lucidConfig.protocolParameters.keyDeposit
    )
  );
  yield* processCertificate(stakeCredential, config, buildCert, redeemer);
});
var registerAndDelegateToDRep = (config, rewardAddress, drep, redeemer) => import_effect12.Effect.gen(function* () {
  const stakeCredential = yield* validateAndGetStakeCredential(
    rewardAddress,
    config
  );
  const cmlDRep = (0, import_core_types.toCMLDRep)(drep);
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_vote_reg_deleg_cert(
      credential,
      cmlDRep,
      config.lucidConfig.protocolParameters.keyDeposit
    )
  );
  yield* processCertificate(stakeCredential, config, buildCert, redeemer);
});
var registerAndDelegateToPoolAndDRep = (config, rewardAddress, poolId, drep, redeemer) => import_effect12.Effect.gen(function* () {
  const stakeCredential = yield* validateAndGetStakeCredential(
    rewardAddress,
    config
  );
  const cmlDRep = (0, import_core_types.toCMLDRep)(drep);
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_stake_vote_reg_deleg_cert(
      credential,
      CML8.Ed25519KeyHash.from_bech32(poolId),
      cmlDRep,
      config.lucidConfig.protocolParameters.keyDeposit
    )
  );
  yield* processCertificate(stakeCredential, config, buildCert, redeemer);
});
var registerDRep = (config, rewardAddress, anchor, redeemer) => import_effect12.Effect.gen(function* () {
  const stakeCredential = yield* validateAndGetStakeCredential(
    rewardAddress,
    config
  );
  const cmlAnchor = anchor ? CML8.Anchor.new(
    CML8.Url.from_json(anchor.url),
    CML8.AnchorDocHash.from_hex(anchor.dataHash)
  ) : void 0;
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_reg_drep_cert(
      credential,
      config.lucidConfig.protocolParameters.drepDeposit,
      cmlAnchor
    )
  );
  yield* processCertificate(stakeCredential, config, buildCert, redeemer);
});
var deregisterDRep = (config, rewardAddress, redeemer) => import_effect12.Effect.gen(function* () {
  const stakeCredential = yield* validateAndGetStakeCredential(
    rewardAddress,
    config
  );
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_unreg_drep_cert(
      credential,
      config.lucidConfig.protocolParameters.drepDeposit
    )
  );
  yield* processCertificate(stakeCredential, config, buildCert, redeemer);
});
var updateDRep = (config, rewardAddress, anchor, redeemer) => import_effect12.Effect.gen(function* () {
  const stakeCredential = yield* validateAndGetStakeCredential(
    rewardAddress,
    config
  );
  const cmlAnchor = anchor ? CML8.Anchor.new(
    CML8.Url.from_json(anchor.url),
    CML8.AnchorDocHash.from_hex(anchor.dataHash)
  ) : void 0;
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_update_drep_cert(credential, cmlAnchor)
  );
  yield* processCertificate(stakeCredential, config, buildCert, redeemer);
});
var authCommitteeHot = (config, coldAddress, hotAddress, redeemer) => import_effect12.Effect.gen(function* () {
  const coldCred = yield* validateAndGetStakeCredential(coldAddress, config);
  const hotCred = yield* validateAndGetStakeCredential(hotAddress, config);
  const hotCredential = hotCred.type === "Key" ? CML8.Credential.new_pub_key(CML8.Ed25519KeyHash.from_hex(hotCred.hash)) : CML8.Credential.new_script(CML8.ScriptHash.from_hex(hotCred.hash));
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_auth_committee_hot_cert(credential, hotCredential)
  );
  yield* processCertificate(coldCred, config, buildCert, redeemer);
});
var resignCommitteeHot = (config, coldAddress, anchor, redeemer) => import_effect12.Effect.gen(function* () {
  const coldCred = yield* validateAndGetStakeCredential(coldAddress, config);
  const cmlAnchor = anchor ? CML8.Anchor.new(
    CML8.Url.from_json(anchor.url),
    CML8.AnchorDocHash.from_hex(anchor.dataHash)
  ) : void 0;
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_resign_committee_cold_cert(credential, cmlAnchor)
  );
  yield* processCertificate(coldCred, config, buildCert, redeemer);
});

// src/tx-builder/internal/Metadata.ts
var import_effect13 = require("effect");
var S = __toESM(require("@effect/schema/Schema"), 1);
var import_core_utils2 = require("@lucid-evolution/core-utils");
var attachMetadata = (config, label, metadata) => import_effect13.Effect.gen(function* () {
  const auxiliaryData = CML.AuxiliaryData.new();
  const meta = CML.Metadata.new();
  meta.set(
    BigInt(label),
    CML.TransactionMetadatum.from_json(
      JSON.stringify(toCardanoMetadata(metadata))
    )
  );
  auxiliaryData.add_metadata(meta);
  config.txBuilder.add_auxiliary_data(auxiliaryData);
  auxiliaryData.free();
  meta.free();
});
var TextSchema = S.String.pipe(S.maxLength(64));
var TransactionMetadataSchema = S.Union(
  TextSchema,
  S.Number,
  S.Uint8ArrayFromSelf,
  S.Array(S.suspend(() => TransactionMetadataSchema)),
  S.Record(
    S.String,
    S.suspend(() => TransactionMetadataSchema)
  )
);
var toCardanoMetadata = (json) => {
  const d = S.asserts(TransactionMetadataSchema)(json);
  if (S.is(TextSchema)(json)) {
    return { string: json };
  }
  if (typeof json === "number") {
    return { int: json };
  }
  if (json instanceof Uint8Array) {
    return { bytes: (0, import_core_utils2.toHex)(json) };
  }
  if (Array.isArray(json)) {
    return { list: json.map((value) => toCardanoMetadata(value)) };
  }
  if (typeof json === "object" && json !== null) {
    const mapEntries = Object.entries(json).map(([k, v]) => ({
      k: toCardanoMetadata(k),
      v: toCardanoMetadata(v)
    }));
    return { map: mapEntries };
  }
  throw new Error("Unsupported type");
};

// src/tx-builder/internal/CompleteTxBuilder.ts
var import_effect17 = require("effect");
var UPLC = __toESM(require("@lucid-evolution/uplc"), 1);

// src/tx-sign-builder/TxSignBuilder.ts
var S3 = __toESM(require("@effect/schema/Schema"), 1);

// src/tx-sign-builder/internal/CompleteTxSigner.ts
var import_effect16 = require("effect");

// src/tx-submit/TxSubmit.ts
var import_effect14 = require("effect");
var S2 = __toESM(require("@effect/schema/Schema"), 1);
var makeSubmit = (wallet, txSigned) => {
  const submit = (options) => import_effect14.Effect.tryPromise({
    try: () => wallet.submitTx(
      options.canonical ? txSigned.to_canonical_cbor_hex() : txSigned.to_cbor_hex()
    ),
    catch: (cause) => new TxSubmitError({ cause })
  });
  return {
    submit: (options = { canonical: false }) => makeReturn(submit(options)).unsafeRun(),
    submitProgram: (options = { canonical: false }) => submit(options),
    submitSafe: (options = { canonical: false }) => makeReturn(submit(options)).safeRun(),
    toCBOR: (options = { canonical: false }) => options.canonical ? txSigned.to_canonical_cbor_hex() : txSigned.to_cbor_hex(),
    toTransaction: () => txSigned,
    toJSON: () => S2.decodeUnknownSync(S2.parseJson(S2.Object))(txSigned.to_json()),
    toHash: () => CML.hash_transaction(txSigned.body()).to_hex()
  };
};

// src/tx-sign-builder/internal/Sign.ts
var import_effect15 = require("effect");
var signError = (cause) => new TxSignerError({ cause });
var mkWitnessFromWallet = (wallet, txComplete) => (0, import_effect15.pipe)(
  import_effect15.Effect.fromNullable(wallet),
  import_effect15.Effect.catchAll(() => signError(ERROR_MESSAGE.MISSING_WALLET)),
  import_effect15.Effect.tryMapPromise({
    try: (wallet2) => wallet2.signTx(txComplete),
    catch: (cause) => signError(cause)
  })
);
var withWallet = (config) => (0, import_effect15.pipe)(
  mkWitnessFromWallet(config.lucidConfig.wallet, config.txComplete),
  import_effect15.Effect.map((witness) => config.witnessSetBuilder.add_existing(witness))
);
var partialWithWallet = (config) => (0, import_effect15.pipe)(
  mkWitnessFromWallet(config.lucidConfig.wallet, config.txComplete),
  import_effect15.Effect.map((witness) => witness.to_cbor_hex())
);
var mkWitnessFromPrivateKey = (privateKey, txComplete) => (0, import_effect15.pipe)(
  import_effect15.Effect.try({
    try: () => CML.PrivateKey.from_bech32(privateKey),
    catch: signError
  }),
  import_effect15.Effect.map(
    (privateKey2) => CML.make_vkey_witness(
      CML.hash_transaction(txComplete.body()),
      privateKey2
    )
  )
);
var withPrivateKey = (config, privateKey) => (0, import_effect15.pipe)(
  mkWitnessFromPrivateKey(privateKey, config.txComplete),
  import_effect15.Effect.map((witness) => config.witnessSetBuilder.add_vkey(witness))
);
var partialWithPrivateKey = (config, privateKey) => (0, import_effect15.pipe)(
  mkWitnessFromPrivateKey(privateKey, config.txComplete),
  import_effect15.Effect.map((witness) => {
    const witnessBuilder = CML.TransactionWitnessSetBuilder.new();
    witnessBuilder.add_vkey(witness);
    return witnessBuilder.build().to_cbor_hex();
  })
);
var assemble = (config, witnesses) => import_effect15.Effect.forEach(
  witnesses,
  (witness) => (0, import_effect15.pipe)(
    import_effect15.Effect.try({
      try: () => CML.TransactionWitnessSet.from_cbor_hex(witness),
      catch: signError
    }),
    import_effect15.Effect.map((witness2) => config.witnessSetBuilder.add_existing(witness2))
  )
);

// src/tx-sign-builder/internal/CompleteTxSigner.ts
var completeTxSigner = (config) => import_effect16.Effect.gen(function* () {
  yield* import_effect16.Effect.all(config.programs, { concurrency: "unbounded" });
  const plutus_datums = config.txComplete.witness_set().plutus_datums();
  config.witnessSetBuilder.add_existing(config.txComplete.witness_set());
  if (plutus_datums) {
    for (let i = 0; i < plutus_datums.len(); i++) {
      config.witnessSetBuilder.add_plutus_datum(plutus_datums.get(i));
    }
  }
  const txWitnessSet = config.witnessSetBuilder.build();
  const signedTx = CML.Transaction.new(
    config.txComplete.body(),
    txWitnessSet,
    true,
    config.txComplete.auxiliary_data()
  );
  const wallet = yield* (0, import_effect16.pipe)(
    import_effect16.Effect.fromNullable(config.lucidConfig.wallet),
    import_effect16.Effect.orElseFail(() => signError(ERROR_MESSAGE.MISSING_WALLET))
  );
  return makeSubmit(wallet, signedTx);
}).pipe(import_effect16.Effect.catchAllDefect((cause) => new RunTimeError({ cause })));

// src/tx-sign-builder/TxSignBuilder.ts
var makeTxSignBuilder = (lucidConfig, tx) => {
  const redeemers = tx.witness_set().redeemers();
  const exUnits = { cpu: 0, mem: 0 };
  if (redeemers) {
    const arrLegacyRedeemer = redeemers?.as_arr_legacy_redeemer();
    if (arrLegacyRedeemer) {
      for (let i = 0; i < arrLegacyRedeemer.len(); i++) {
        const redeemer = arrLegacyRedeemer.get(i);
        exUnits.cpu += parseInt(redeemer.ex_units().steps().toString());
        exUnits.mem += parseInt(redeemer.ex_units().mem().toString());
      }
    }
    const mapRedeemerKeyToRedeemerVal = redeemers?.as_map_redeemer_key_to_redeemer_val();
    if (mapRedeemerKeyToRedeemerVal) {
      const keys = mapRedeemerKeyToRedeemerVal.keys();
      for (let i = 0; i < (keys.len() || 0); i++) {
        const key = keys.get(i);
        const value = mapRedeemerKeyToRedeemerVal.get(key);
        exUnits.cpu += parseInt(value.ex_units().steps().toString());
        exUnits.mem += parseInt(value.ex_units().mem().toString());
      }
    }
  }
  const config = {
    txComplete: tx,
    witnessSetBuilder: CML.TransactionWitnessSetBuilder.new(),
    programs: [],
    lucidConfig,
    fee: parseInt(tx.body().fee().toString()),
    exUnits
  };
  const txSignBuilder = {
    sign: {
      withWallet: () => {
        const program = withWallet(config);
        config.programs.push(program);
        return txSignBuilder;
      },
      withPrivateKey: (privateKey) => {
        const program = withPrivateKey(config, privateKey);
        config.programs.push(program);
        return txSignBuilder;
      }
    },
    partialSign: {
      withWallet: () => makeReturn(partialWithWallet(config)).unsafeRun(),
      withWalletEffect: () => partialWithWallet(config),
      withWalletSafe: () => makeReturn(partialWithWallet(config)).safeRun(),
      withPrivateKey: (privateKey) => makeReturn(partialWithPrivateKey(config, privateKey)).unsafeRun(),
      withPrivateKeyEffect: (privateKey) => partialWithPrivateKey(config, privateKey),
      withPrivateKeySafe: (privateKey) => makeReturn(partialWithPrivateKey(config, privateKey)).safeRun()
    },
    assemble: (witnesses) => {
      const program = assemble(config, witnesses);
      config.programs.push(program);
      return txSignBuilder;
    },
    toCBOR: (options = { canonical: false }) => options.canonical ? config.txComplete.to_canonical_cbor_hex() : config.txComplete.to_cbor_hex(),
    toTransaction: () => config.txComplete,
    toJSON: () => S3.decodeUnknownSync(S3.parseJson(S3.Object))(config.txComplete.to_json()),
    toHash: () => CML.hash_transaction(config.txComplete.body()).to_hex(),
    complete: () => makeReturn(completeTxSigner(config)).unsafeRun(),
    completeProgram: () => completeTxSigner(config),
    completeSafe: () => makeReturn(completeTxSigner(config)).safeRun()
  };
  return txSignBuilder;
};

// src/tx-builder/internal/CompleteTxBuilder.ts
var import_utils11 = require("@lucid-evolution/utils");
var import_plutus4 = require("@lucid-evolution/plutus");
var completeTxError = (cause) => new TxBuilderError({ cause: `{ Complete: ${cause} }` });
var complete = (config, options = {}) => import_effect17.Effect.gen(function* () {
  const wallet = yield* (0, import_effect17.pipe)(
    import_effect17.Effect.fromNullable(config.lucidConfig.wallet),
    import_effect17.Effect.orElseFail(() => completeTxError(ERROR_MESSAGE.MISSING_WALLET))
  );
  const walletAddress = yield* import_effect17.Effect.promise(() => wallet.address());
  const {
    coinSelection = true,
    changeAddress = walletAddress,
    localUPLCEval = true,
    setCollateral = 5000000n,
    canonical = false,
    includeLeftoverLovelaceAsFee = false,
    presetWalletInputs = []
  } = options;
  const walletInputs = presetWalletInputs.length === 0 ? yield* import_effect17.Effect.tryPromise({
    try: () => wallet.getUtxos(),
    catch: (error) => completeTxError(error)
  }) : presetWalletInputs;
  yield* import_effect17.Effect.all(config.programs);
  const hasPlutusScriptExecutions = Array.from(
    config.scripts.values()
  ).some((value) => value.type !== "Native");
  if (hasPlutusScriptExecutions) {
    const collateralInput = yield* findCollateral(
      config.lucidConfig.protocolParameters.coinsPerUtxoByte,
      setCollateral,
      walletInputs
    );
    applyCollateral(config, setCollateral, collateralInput, changeAddress);
  }
  yield* selectionAndEvaluation(
    config,
    walletInputs,
    changeAddress,
    coinSelection,
    localUPLCEval,
    includeLeftoverLovelaceAsFee,
    false
  );
  if (hasPlutusScriptExecutions)
    yield* selectionAndEvaluation(
      config,
      walletInputs,
      changeAddress,
      coinSelection,
      localUPLCEval,
      includeLeftoverLovelaceAsFee,
      true
    );
  config.txBuilder.add_change_if_needed(
    CML.Address.from_bech32(changeAddress),
    true
  );
  const transaction = yield* import_effect17.Effect.try({
    try: () => config.txBuilder.build(
      CML.ChangeSelectionAlgo.Default,
      CML.Address.from_bech32(changeAddress)
    ).build_unchecked(),
    catch: (error) => completeTxError(error)
  });
  const derivedInputs = deriveInputsFromTransaction(transaction);
  const derivedWalletInputs = derivedInputs.filter(
    (utxo) => utxo.address === walletAddress
  );
  const updatedWalletInputs = (0, import_effect17.pipe)(
    import_effect17.Array.differenceWith(import_utils11.isEqualUTxO)(walletInputs, config.consumedInputs),
    (availableWalletInputs) => [
      ...derivedWalletInputs,
      ...availableWalletInputs
    ]
  );
  return import_effect17.Tuple.make(
    updatedWalletInputs,
    derivedInputs,
    makeTxSignBuilder(
      config.lucidConfig,
      canonical ? CML.Transaction.from_cbor_bytes(
        transaction.to_canonical_cbor_bytes()
      ) : transaction
    )
  );
}).pipe(import_effect17.Effect.catchAllDefect((cause) => new RunTimeError({ cause })));
var selectionAndEvaluation = (config, walletInputs, changeAddress, coinSelection, localUPLCEval, includeLeftoverLovelaceAsFee, script_calculation) => import_effect17.Effect.gen(function* () {
  const availableInputs = import_effect17.Array.differenceWith(import_utils11.isEqualUTxO)(
    walletInputs,
    config.collectedInputs
  );
  const { selected: inputsToAdd, burnable } = coinSelection !== false ? yield* doCoinSelection(
    config,
    availableInputs,
    script_calculation,
    includeLeftoverLovelaceAsFee
  ) : { selected: [], burnable: {} };
  let estimatedFee = 0n;
  if (import_effect17.Array.isEmptyArray(inputsToAdd)) {
    if (script_calculation) return;
    estimatedFee += burnable.lovelace;
  }
  if (import_effect17.Array.isNonEmptyArray(inputsToAdd)) {
    for (const utxo of inputsToAdd) {
      const input = CML.SingleInputBuilder.from_transaction_unspent_output(
        (0, import_utils11.utxoToCore)(utxo)
      ).payment_key();
      config.txBuilder.add_input(input);
    }
    config.collectedInputs = [...config.collectedInputs, ...inputsToAdd];
    estimatedFee = yield* estimateFee(config, script_calculation);
  }
  config.consumedInputs = [...config.collectedInputs];
  if (config.partialPrograms.size > 0) {
    if (script_calculation) {
      yield* completeTxError(
        `RedeemerBuilder: Coin selection had to be updated after building redeemers, possibly leading to incorrect indices. Try setting a minimum fee of ${estimatedFee} lovelaces.`
      );
    } else yield* completePartialPrograms(config);
  }
  const txRedeemerBuilder = yield* import_effect17.Effect.try({
    try: () => config.txBuilder.build_for_evaluation(
      0,
      CML.Address.from_bech32(changeAddress)
    ),
    catch: (error) => completeTxError(error)
  });
  if (txRedeemerBuilder.draft_tx().witness_set().redeemers()) {
    if (localUPLCEval !== false) {
      applyUPLCEval(
        yield* evalTransaction(config, txRedeemerBuilder, walletInputs),
        config.txBuilder
      );
    } else {
      applyUPLCEvalProvider(
        yield* evalTransactionProvider(
          config,
          txRedeemerBuilder,
          walletInputs
        ),
        config.txBuilder
      );
    }
  }
}).pipe(import_effect17.Effect.catchAllDefect((cause) => new RunTimeError({ cause })));
var completePartialPrograms = (config) => import_effect17.Effect.gen(function* () {
  const sortedInputs = (0, import_utils11.sortUTxOs)(config.collectedInputs, "Canonical");
  const indicesMap = /* @__PURE__ */ new Map();
  sortedInputs.forEach((value, index) => {
    indicesMap.set(value.txHash + value.outputIndex, BigInt(index));
  });
  const newPrograms = [];
  for (const [
    redeemerBuilder,
    partialProgram
  ] of config.partialPrograms.entries()) {
    if (redeemerBuilder.kind === "selected") {
      const inputIndices = redeemerBuilder.inputs.flatMap((value) => {
        const index = indicesMap.get(value.txHash + value.outputIndex);
        if (index !== void 0) return index;
        else return [];
      });
      if (import_effect17.Array.isEmptyArray(inputIndices) || inputIndices.length !== redeemerBuilder.inputs.length)
        yield* completeTxError(
          `RedeemerBuilder: Missing indices for inputs: ${(0, import_utils11.stringify)(redeemerBuilder.inputs)}`
        );
      const redeemer = redeemerBuilder.makeRedeemer(inputIndices);
      const program = partialProgram(redeemer);
      newPrograms.push(program);
    } else {
      const inputs = yield* (0, import_effect17.pipe)(
        import_effect17.Effect.fromNullable(redeemerBuilder.inputs),
        import_effect17.Effect.orElseFail(
          () => completeTxError(
            `RedeemerBuilder: Inputs for redeemer builder not founds: ${(0, import_utils11.stringify)(redeemerBuilder)}`
          )
        )
      );
      for (const input of inputs) {
        const index = yield* (0, import_effect17.pipe)(
          import_effect17.Effect.fromNullable(
            indicesMap.get(input.txHash + input.outputIndex)
          ),
          import_effect17.Effect.orElseFail(
            () => completeTxError(`Index not found for input: ${input}`)
          )
        );
        const redeemer = redeemerBuilder.makeRedeemer(index);
        const program = collectFromUTxO(config, [input], false)(redeemer);
        newPrograms.push(program);
      }
    }
  }
  yield* import_effect17.Effect.all(newPrograms);
});
var applyUPLCEval = (uplcEval, txbuilder) => {
  for (const bytes of uplcEval) {
    const redeemer = CML.LegacyRedeemer.from_cbor_bytes(bytes);
    const exUnits = CML.ExUnits.new(
      redeemer.ex_units().mem(),
      redeemer.ex_units().steps()
    );
    txbuilder.set_exunits(
      CML.RedeemerWitnessKey.new(redeemer.tag(), redeemer.index()),
      exUnits
    );
  }
};
var applyUPLCEvalProvider = (evalRedeemerList, txbuilder) => {
  for (const evalRedeemer of evalRedeemerList) {
    const exUnits = CML.ExUnits.new(
      BigInt(evalRedeemer.ex_units.mem),
      BigInt(evalRedeemer.ex_units.steps)
    );
    txbuilder.set_exunits(
      CML.RedeemerWitnessKey.new(
        (0, import_utils11.toCMLRedeemerTag)(evalRedeemer.redeemer_tag),
        BigInt(evalRedeemer.redeemer_index)
      ),
      exUnits
    );
  }
};
var setRedeemerstoZero = (tx) => {
  const redeemers = tx.witness_set().redeemers();
  if (!redeemers) return tx;
  const arrLegacyRedeemer = redeemers.as_arr_legacy_redeemer();
  if (arrLegacyRedeemer) {
    const redeemerList = CML.LegacyRedeemerList.new();
    for (let i = 0; i < arrLegacyRedeemer.len(); i++) {
      const redeemer = arrLegacyRedeemer.get(i);
      const dummyRedeemer = CML.LegacyRedeemer.new(
        redeemer.tag(),
        redeemer.index(),
        redeemer.data(),
        CML.ExUnits.new(0n, 0n)
      );
      redeemerList.add(dummyRedeemer);
    }
    const dummyWitnessSet = tx.witness_set();
    dummyWitnessSet.set_redeemers(
      CML.Redeemers.new_arr_legacy_redeemer(redeemerList)
    );
    return CML.Transaction.new(
      tx.body(),
      dummyWitnessSet,
      true,
      tx.auxiliary_data()
    );
  }
  const mapRedeemerKeyToRedeemerVal = redeemers.as_map_redeemer_key_to_redeemer_val();
  if (mapRedeemerKeyToRedeemerVal) {
    const dummyWitnessSet = tx.witness_set();
    dummyWitnessSet.set_redeemers(
      CML.Redeemers.new_map_redeemer_key_to_redeemer_val(
        mapRedeemerKeyToRedeemerVal
      )
    );
    return CML.Transaction.new(
      tx.body(),
      dummyWitnessSet,
      true,
      tx.auxiliary_data()
    );
  }
  return tx;
};
var applyCollateral = (config, setCollateral, collateralInputs, changeAddress) => {
  for (const utxo of collateralInputs) {
    const collateralInput = CML.SingleInputBuilder.from_transaction_unspent_output(
      (0, import_utils11.utxoToCore)(utxo)
    ).payment_key();
    config.txBuilder.add_collateral(collateralInput);
  }
  const returnassets = (0, import_effect17.pipe)(
    sumAssetsFromInputs(collateralInputs),
    import_effect17.Record.union({ lovelace: -setCollateral }, import_effect17.BigInt.sum)
  );
  const collateralOutputBuilder = CML.TransactionOutputBuilder.new().with_address(
    CML.Address.from_bech32(changeAddress)
  );
  config.txBuilder.set_collateral_return(
    collateralOutputBuilder.next().with_value((0, import_utils11.assetsToValue)(returnassets)).build().output()
  );
};
var findCollateral = (coinsPerUtxoByte, setCollateral, inputs) => import_effect17.Effect.gen(function* () {
  const collateralLovelace = { lovelace: setCollateral };
  const error = completeTxError(
    `Your wallet does not have enough funds to cover the required ${setCollateral} Lovelace collateral. Or it contains UTxOs with reference scripts; which
      are excluded from collateral selection.`
  );
  const { selected } = yield* recursive(
    (0, import_utils11.sortUTxOs)(inputs),
    collateralLovelace,
    coinsPerUtxoByte,
    void 0,
    false,
    error
  );
  if (selected.length > 3)
    yield* completeTxError(
      `Selected ${selected.length} inputs as collateral, but max collateral inputs is 3 to cover the ${setCollateral} Lovelace collateral ${(0, import_utils11.stringify)(selected)}`
    );
  return selected;
});
var doCoinSelection = (config, availableInputs, script_calculation, includeLeftoverLovelaceAsFee) => import_effect17.Effect.gen(function* () {
  const estimatedFee = {
    lovelace: yield* estimateFee(config, script_calculation)
  };
  const negatedMintedAssets = negateAssets(config.mintedAssets);
  const negatedCollectedAssets = negateAssets(
    sumAssetsFromInputs(config.collectedInputs)
  );
  const assetsDelta = (0, import_effect17.pipe)(
    config.totalOutputAssets,
    import_effect17.Record.union(estimatedFee, import_effect17.BigInt.sum),
    import_effect17.Record.union(negatedCollectedAssets, import_effect17.BigInt.sum),
    import_effect17.Record.union(negatedMintedAssets, import_effect17.BigInt.sum)
  );
  let requiredAssets = (0, import_effect17.pipe)(
    assetsDelta,
    import_effect17.Record.filter((amount) => amount > 0n)
  );
  const notRequiredAssets = (0, import_effect17.pipe)(
    assetsDelta,
    import_effect17.Record.filter((amount) => amount < 0n),
    negateAssets
  );
  return yield* recursive(
    (0, import_utils11.sortUTxOs)(availableInputs),
    requiredAssets,
    config.lucidConfig.protocolParameters.coinsPerUtxoByte,
    notRequiredAssets,
    includeLeftoverLovelaceAsFee
  );
});
var estimateFee = (config, script_calculation) => import_effect17.Effect.gen(function* () {
  const minFee = config.txBuilder.min_fee(script_calculation);
  const refScriptFee = yield* calculateMinRefScriptFee(config);
  let estimatedFee = minFee + refScriptFee;
  const customMinFee = config.minFee;
  if (customMinFee !== void 0 && customMinFee > minFee || refScriptFee > 0n) {
    estimatedFee = customMinFee ? customMinFee > estimatedFee ? customMinFee : estimatedFee : estimatedFee;
    config.txBuilder.set_fee(estimatedFee);
  }
  return estimatedFee;
});
var evalTransactionProvider = (config, txRedeemerBuilder, walletInputs) => import_effect17.Effect.gen(function* () {
  const txEvaluation = setRedeemerstoZero(txRedeemerBuilder.draft_tx());
  const txUtxos = [...config.collectedInputs, ...config.readInputs];
  const uplc_eval = yield* import_effect17.Effect.tryPromise({
    try: () => config.lucidConfig.provider.evaluateTx(
      txEvaluation.to_cbor_hex(),
      txUtxos
    ),
    catch: (error) => completeTxError(error)
  });
  return uplc_eval;
});
var evalTransaction = (config, txRedeemerBuilder, walletInputs) => import_effect17.Effect.gen(function* () {
  const txEvaluation = setRedeemerstoZero(txRedeemerBuilder.draft_tx());
  const txUtxos = [
    ...walletInputs,
    ...config.collectedInputs,
    ...config.readInputs
  ];
  const ins = txUtxos.map((utxo) => (0, import_utils11.utxoToTransactionInput)(utxo));
  const outs = txUtxos.map((utxo) => (0, import_utils11.utxoToTransactionOutput)(utxo));
  const slotConfig = import_plutus4.SLOT_CONFIG_NETWORK[config.lucidConfig.network];
  const uplc_eval = yield* import_effect17.Effect.try({
    try: () => UPLC.eval_phase_two_raw(
      txEvaluation.to_cbor_bytes(),
      ins.map((value) => value.to_cbor_bytes()),
      outs.map((value) => value.to_cbor_bytes()),
      config.lucidConfig.costModels.to_cbor_bytes(),
      config.lucidConfig.protocolParameters.maxTxExSteps,
      config.lucidConfig.protocolParameters.maxTxExMem,
      BigInt(slotConfig.zeroTime),
      BigInt(slotConfig.zeroSlot),
      slotConfig.slotLength
    ),
    catch: (error) => completeTxError(
      JSON.stringify(error).replace(/\\n\s*/g, " ").trim()
    )
  });
  return uplc_eval;
});
var calculateMinLovelace = (coinsPerUtxoByte, multiAssets, changeAddress) => {
  const dummyAddress = "addr_test1qrngfyc452vy4twdrepdjc50d4kvqutgt0hs9w6j2qhcdjfx0gpv7rsrjtxv97rplyz3ymyaqdwqa635zrcdena94ljs0xy950";
  return CML.TransactionOutputBuilder.new().with_address(
    CML.Address.from_bech32(changeAddress ? changeAddress : dummyAddress)
  ).next().with_asset_and_min_required_coin(
    multiAssets ? (0, import_utils11.assetsToValue)(multiAssets).multi_asset() : CML.MultiAsset.new(),
    coinsPerUtxoByte
  ).build().output().amount().coin();
};
var calculateMinRefScriptFee = (config) => import_effect17.Effect.gen(function* () {
  let fee = 0n;
  let totalScriptSize = 0;
  config.readInputs.forEach((utxo) => {
    if (utxo.scriptRef) {
      totalScriptSize = totalScriptSize + utxo.scriptRef.script.length / 2;
    }
  });
  config.collectedInputs.forEach((utxo) => {
    if (utxo.scriptRef) {
      totalScriptSize = totalScriptSize + utxo.scriptRef.script.length / 2;
    }
  });
  if (totalScriptSize === 0) return fee;
  const fees = [15, 18, 21.6, 25.92, 31.1, 37.32, 44.79, 53.75];
  let counter = 0;
  while (totalScriptSize > 0) {
    if (counter > fees.length - 1) {
      yield* completeTxError(
        "Total reference script size in a transaction cannot exceed 200,000 bytes."
      );
    }
    if (totalScriptSize > 25e3) fee = fee + BigInt(25e3 * fees[counter]);
    else fee = fee + BigInt(totalScriptSize * fees[counter]);
    totalScriptSize = totalScriptSize - 25e3;
    counter++;
  }
  return fee;
});
var deriveInputsFromTransaction = (tx) => {
  const outputs = tx.body().outputs();
  const txHash = CML.hash_transaction(tx.body()).to_hex();
  const utxos = [];
  for (let index = 0; index < outputs.len(); index++) {
    const output = outputs.get(index);
    const utxo = {
      txHash,
      outputIndex: index,
      ...(0, import_utils11.coreToTxOutput)(output)
    };
    utxos.push(utxo);
  }
  return utxos;
};
var negateAssets = (assets) => import_effect17.Record.map(assets, (amount) => -amount);
var sumAssetsFromInputs = (inputs) => import_effect17.Array.isEmptyArray(inputs) ? {} : inputs.map((utxo) => utxo.assets).reduce((acc, cur) => import_effect17.Record.union(acc, cur, import_effect17.BigInt.sum));
var calculateExtraLovelace = (leftoverAssets, coinsPerUtxoByte) => {
  return (0, import_effect17.pipe)(leftoverAssets, (assets) => {
    const minLovelace = calculateMinLovelace(coinsPerUtxoByte, assets);
    const currentLovelace = assets["lovelace"] || 0n;
    return currentLovelace >= minLovelace ? import_effect17.Option.none() : import_effect17.Option.some({ lovelace: minLovelace - currentLovelace });
  });
};
var recursive = (inputs, requiredAssets, coinsPerUtxoByte, externalAssets = {}, includeLeftoverLovelaceAsFee, error) => import_effect17.Effect.gen(function* () {
  let selected = [];
  error ??= completeTxError(
    `Your wallet does not have enough funds to cover the required assets: ${(0, import_utils11.stringify)(requiredAssets)}
      Or it contains UTxOs with reference scripts; which are excluded from coin selection.`
  );
  if (!import_effect17.Record.isEmptyRecord(requiredAssets)) {
    selected = (0, import_utils11.selectUTxOs)(inputs, requiredAssets);
    if (import_effect17.Array.isEmptyArray(selected)) yield* error;
  }
  const selectedAssets = sumAssetsFromInputs(selected);
  let availableAssets = (0, import_effect17.pipe)(
    selectedAssets,
    import_effect17.Record.union(requiredAssets, (self, that) => self - that),
    import_effect17.Record.union(externalAssets, import_effect17.BigInt.sum)
  );
  let extraLovelace = (0, import_effect17.pipe)(
    calculateExtraLovelace(availableAssets, coinsPerUtxoByte),
    import_effect17.Option.getOrUndefined
  );
  let remainingInputs = inputs;
  while (extraLovelace) {
    remainingInputs = import_effect17.Array.differenceWith(import_utils11.isEqualUTxO)(
      remainingInputs,
      selected
    );
    const extraSelected = (0, import_utils11.selectUTxOs)(remainingInputs, extraLovelace);
    if (import_effect17.Array.isEmptyArray(extraSelected)) {
      if (includeLeftoverLovelaceAsFee)
        return { selected: [...selected], burnable: extraLovelace };
      yield* completeTxError(
        `Your wallet does not have enough funds to cover required minimum ADA for change output: ${(0, import_utils11.stringify)(extraLovelace)}
          Or it contains UTxOs with reference scripts; which are excluded from coin selection.`
      );
    }
    const extraSelectedAssets = sumAssetsFromInputs(extraSelected);
    selected = [...selected, ...extraSelected];
    availableAssets = import_effect17.Record.union(
      availableAssets,
      extraSelectedAssets,
      import_effect17.BigInt.sum
    );
    extraLovelace = (0, import_effect17.pipe)(
      calculateExtraLovelace(availableAssets, coinsPerUtxoByte),
      import_effect17.Option.getOrUndefined
    );
  }
  return { selected, burnable: { lovelace: 0n } };
});

// src/tx-builder/TxBuilder.ts
var import_effect18 = require("effect");
var import_utils12 = require("@lucid-evolution/utils");
function makeTxBuilder(lucidConfig) {
  const config = {
    lucidConfig,
    txBuilder: CML.TransactionBuilder.new(lucidConfig.txbuilderconfig),
    walletInputs: [],
    collectedInputs: [],
    readInputs: [],
    consumedInputs: [],
    totalOutputAssets: {},
    payToOutputs: [],
    mintedAssets: {},
    scripts: /* @__PURE__ */ new Map(),
    programs: [],
    partialPrograms: /* @__PURE__ */ new Map(),
    minFee: void 0
  };
  const txBuilder = {
    readFrom: (utxos) => {
      utxos.map((utxo) => {
        if (utxo.scriptRef) {
          const scriptKeyValue = attachScript(utxo.scriptRef);
          config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        }
      });
      const program = readFrom(config, utxos);
      config.programs.push(program);
      return txBuilder;
    },
    collectFrom: (utxos, redeemer) => {
      const program = typeof redeemer === "object" ? collectFromUTxOPartial(config, utxos, redeemer) : collectFromUTxO(config, utxos)(redeemer);
      config.programs.push(program);
      return txBuilder;
    },
    pay: {
      ToAddress: (address, assets) => {
        const program = payToAddress(config, address, assets);
        config.programs.push(program);
        return txBuilder;
      },
      ToAddressWithData: (address, outputDatum, assets, scriptRef) => {
        const program = payToAddressWithData(
          config,
          address,
          outputDatum,
          assets,
          scriptRef
        );
        config.programs.push(program);
        return txBuilder;
      },
      ToContract: (address, outputDatum, assets, scriptRef) => {
        const program = payToContract(
          config,
          address,
          outputDatum,
          assets,
          scriptRef
        );
        config.programs.push(program);
        return txBuilder;
      }
    },
    addSigner: (address) => {
      const program = addSigner(config, address);
      config.programs.push(program);
      return txBuilder;
    },
    addSignerKey: (keyHash) => {
      const program = addSignerKey(config, keyHash);
      config.programs.push(program);
      return txBuilder;
    },
    registerStake: (rewardAddress) => {
      const program = registerStake(config, rewardAddress);
      config.programs.push(program);
      return txBuilder;
    },
    register: {
      Stake: (rewardAddress) => {
        const program = registerStake(config, rewardAddress);
        config.programs.push(program);
        return txBuilder;
      },
      DRep: (rewardAddress, anchor, redeemer) => {
        const program = registerDRep(
          config,
          rewardAddress,
          anchor,
          redeemer
        );
        config.programs.push(program);
        return txBuilder;
      }
    },
    deRegisterStake: (rewardAddress, redeemer) => {
      const program = deRegisterStake(config, rewardAddress, redeemer);
      config.programs.push(program);
      return txBuilder;
    },
    deregister: {
      Stake: (rewardAddress, redeemer) => {
        const program = deRegisterStake(config, rewardAddress, redeemer);
        config.programs.push(program);
        return txBuilder;
      },
      DRep: (rewardAddress, redeemer) => {
        const program = deregisterDRep(
          config,
          rewardAddress,
          redeemer
        );
        config.programs.push(program);
        return txBuilder;
      }
    },
    withdraw: (rewardAddress, amount, redeemer) => {
      const partialProgram = withdraw(config, rewardAddress, amount);
      handleRedeemerBuilder(config, partialProgram, redeemer);
      return txBuilder;
    },
    mintAssets: (assets, redeemer) => {
      config.mintedAssets = (0, import_utils12.addAssets)(config.mintedAssets, assets);
      const partialProgram = mintAssets(config, assets);
      handleRedeemerBuilder(config, partialProgram, redeemer);
      return txBuilder;
    },
    validFrom: (unixTime) => {
      const program = validFrom(config, unixTime);
      config.programs.push(program);
      return txBuilder;
    },
    validTo: (unixTime) => {
      const program = validTo(config, unixTime);
      config.programs.push(program);
      return txBuilder;
    },
    delegateTo: (rewardAddress, poolId, redeemer) => {
      const program = delegateTo(config, rewardAddress, poolId, redeemer);
      config.programs.push(program);
      return txBuilder;
    },
    delegate: {
      ToPool: (rewardAddress, poolId, redeemer) => {
        const program = delegateTo(
          config,
          rewardAddress,
          poolId,
          redeemer
        );
        config.programs.push(program);
        return txBuilder;
      },
      VoteToDRep: (rewardAddress, drep, redeemer) => {
        const program = delegateVoteToDRep(
          config,
          rewardAddress,
          drep,
          redeemer
        );
        config.programs.push(program);
        return txBuilder;
      },
      VoteToPoolAndDRep: (rewardAddress, poolId, drep, redeemer) => {
        const program = delegateVoteToPoolAndDRep(
          config,
          rewardAddress,
          poolId,
          drep,
          redeemer
        );
        config.programs.push(program);
        return txBuilder;
      }
    },
    registerAndDelegate: {
      ToPool: (rewardAddress, poolId, redeemer) => {
        const program = registerAndDelegateToPool(
          config,
          rewardAddress,
          poolId,
          redeemer
        );
        config.programs.push(program);
        return txBuilder;
      },
      ToDRep: (rewardAddress, drep, redeemer) => {
        const program = registerAndDelegateToDRep(
          config,
          rewardAddress,
          drep,
          redeemer
        );
        config.programs.push(program);
        return txBuilder;
      },
      ToPoolAndDRep: (rewardAddress, poolId, drep, redeemer) => {
        const program = registerAndDelegateToPoolAndDRep(
          config,
          rewardAddress,
          poolId,
          drep,
          redeemer
        );
        config.programs.push(program);
        return txBuilder;
      }
    },
    updateDRep: (rewardAddress, anchor, redeemer) => {
      const program = updateDRep(
        config,
        rewardAddress,
        anchor,
        redeemer
      );
      config.programs.push(program);
      return txBuilder;
    },
    authCommitteeHot: (coldAddress, hotAddress, redeemer) => {
      const program = authCommitteeHot(
        config,
        coldAddress,
        hotAddress,
        redeemer
      );
      config.programs.push(program);
      return txBuilder;
    },
    resignCommitteeHot: (coldAddress, anchor, redeemer) => {
      const program = resignCommitteeHot(
        config,
        coldAddress,
        anchor,
        redeemer
      );
      config.programs.push(program);
      return txBuilder;
    },
    attachMetadata: (label, metadata) => {
      const program = attachMetadata(config, label, metadata);
      config.programs.push(program);
      return txBuilder;
    },
    attach: {
      Script: (script) => {
        const scriptKeyValue = attachScript(script);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      SpendingValidator: (spendingValidator) => {
        const scriptKeyValue = attachSpendingValidator(spendingValidator);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      MintingPolicy: (mintingPolicy) => {
        const scriptKeyValue = attachMintingPolicy(mintingPolicy);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      CertificateValidator: (certValidator) => {
        const scriptKeyValue = attachCertificateValidator(certValidator);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      WithdrawalValidator: (withdrawalValidator) => {
        const scriptKeyValue = attachWithdrawalValidator(withdrawalValidator);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      VoteValidator: (voteValidator) => {
        const scriptKeyValue = attachVoteValidator(voteValidator);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      ProposeValidator: (proposeValidator) => {
        const scriptKeyValue = attachProposeValidator(proposeValidator);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      }
    },
    compose: (tx) => {
      if (tx) {
        const program = import_effect18.Effect.gen(function* () {
          const config2 = yield* import_effect18.Effect.promise(() => tx.config());
          yield* import_effect18.Effect.all(config2.programs, { concurrency: "unbounded" });
        });
        config.programs.push(program);
      }
      return txBuilder;
    },
    setMinFee: (fee) => {
      config.minFee = fee;
      return txBuilder;
    },
    complete: (options) => makeReturn(
      complete(config, options).pipe(
        import_effect18.Effect.map((result) => result[2])
      )
    ).unsafeRun(),
    completeProgram: (options) => complete(config, options).pipe(
      import_effect18.Effect.map((result) => result[2])
    ),
    completeSafe: (options) => makeReturn(
      complete(config, options).pipe(
        import_effect18.Effect.map((result) => result[2])
      )
    ).safeRun(),
    chainProgram: (options) => complete(config, options),
    chain: (options) => makeReturn(complete(config, options)).unsafeRun(),
    chainSafe: (options) => makeReturn(complete(config, options)).safeRun(),
    config: () => import_effect18.Effect.gen(function* () {
      yield* import_effect18.Effect.all(config.programs);
      return config;
    }).pipe(import_effect18.Effect.runPromise),
    lucidConfig: () => config.lucidConfig
  };
  return txBuilder;
}

// src/tx-builder/TxConfig.ts
var makeTxConfig = (protocolParameters, costModels) => {
  const exUnitsPrices = CML.ExUnitPrices.new(
    CML.Rational.new(
      BigInt(protocolParameters.priceMem * 1e8),
      100000000n
    ),
    CML.Rational.new(
      BigInt(protocolParameters.priceStep * 1e8),
      100000000n
    )
  );
  const txBuilderConfig = CML.TransactionBuilderConfigBuilder.new().fee_algo(
    CML.LinearFee.new(
      BigInt(protocolParameters.minFeeA),
      BigInt(protocolParameters.minFeeB),
      BigInt(protocolParameters.minFeeRefScriptCostPerByte)
    )
  ).coins_per_utxo_byte(protocolParameters.coinsPerUtxoByte).pool_deposit(protocolParameters.poolDeposit).key_deposit(protocolParameters.keyDeposit).max_value_size(protocolParameters.maxValSize).max_tx_size(protocolParameters.maxTxSize).ex_unit_prices(exUnitsPrices).collateral_percentage(protocolParameters.collateralPercentage).max_collateral_inputs(protocolParameters.maxCollateralInputs).cost_models(costModels).collateral_percentage(protocolParameters.collateralPercentage).max_collateral_inputs(protocolParameters.maxCollateralInputs).build();
  return txBuilderConfig;
};

// src/lucid-evolution/LucidEvolution.ts
var import_plutus5 = require("@lucid-evolution/plutus");
var import_wallet = require("@lucid-evolution/wallet");
var Lucid = async (provider, network, options = {}) => {
  const protocolParameters = options.presetProtocolParameters || await provider.getProtocolParameters();
  const costModels = (0, import_utils14.createCostModels)(protocolParameters.costModels);
  const config = {
    provider,
    network,
    wallet: void 0,
    costModels,
    txbuilderconfig: makeTxConfig(protocolParameters, costModels),
    protocolParameters
  };
  if ("slot" in config.provider) {
    const emulator = config.provider;
    import_plutus5.SLOT_CONFIG_NETWORK[network] = {
      zeroTime: emulator.now(),
      zeroSlot: 0,
      slotLength: 1e3
    };
  }
  return {
    config: () => config,
    wallet: () => config.wallet,
    overrideUTxOs: (utxos) => config.wallet?.overrideUTxOs(utxos),
    switchProvider: async (provider2) => {
      const protocolParam = await provider2.getProtocolParameters();
      const costModels2 = (0, import_utils14.createCostModels)(protocolParam.costModels);
      config.provider = provider2;
      config.costModels = costModels2;
      config.txbuilderconfig = makeTxConfig(protocolParam, costModels2);
      config.protocolParameters = protocolParam;
    },
    newTx: () => makeTxBuilder(config),
    fromTx: (tx) => makeTxSignBuilder(
      config,
      CML.Transaction.from_cbor_hex(tx)
    ),
    selectWallet: {
      fromSeed: (seed, options2) => {
        config.wallet = (0, import_wallet.makeWalletFromSeed)(
          config.provider,
          network,
          seed,
          options2
        );
      },
      fromPrivateKey: (privateKey) => {
        config.wallet = (0, import_wallet.makeWalletFromPrivateKey)(
          config.provider,
          network,
          privateKey
        );
      },
      fromAPI: (walletAPI) => {
        config.wallet = (0, import_wallet.makeWalletFromAPI)(config.provider, walletAPI);
      },
      fromAddress: (address, utxos) => {
        config.wallet = (0, import_wallet.makeWalletFromAddress)(
          config.provider,
          network,
          address,
          utxos
        );
      }
    },
    currentSlot: () => {
      return (0, import_utils14.unixTimeToSlot)(config.network, Date.now());
    },
    utxosAt: (addressOrCredential) => config.provider.getUtxos(addressOrCredential),
    utxosAtWithUnit: (addressOrCredential, unit) => config.provider.getUtxosWithUnit(addressOrCredential, unit),
    utxoByUnit: (unit) => config.provider.getUtxoByUnit(unit),
    utxosByOutRef: (outRefs) => config.provider.getUtxosByOutRef(outRefs),
    delegationAt: config.provider.getDelegation,
    awaitTx: (txHash, checkInterval) => config.provider.awaitTx(txHash, checkInterval),
    datumOf: (utxo, type) => datumOf(config.provider, utxo, type),
    metadataOf: (unit) => metadataOf(config.provider, unit)
  };
};

// src/index.ts
__reExport(src_exports, require("@lucid-evolution/core-types"), module.exports);
__reExport(src_exports, require("@lucid-evolution/core-utils"), module.exports);
__reExport(src_exports, require("@lucid-evolution/plutus"), module.exports);
__reExport(src_exports, require("@lucid-evolution/provider"), module.exports);
__reExport(src_exports, require("@lucid-evolution/sign_data"), module.exports);
__reExport(src_exports, require("@lucid-evolution/utils"), module.exports);
__reExport(src_exports, require("@lucid-evolution/wallet"), module.exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CML,
  ERROR_MESSAGE,
  Lucid,
  RunTimeError,
  TxBuilderError,
  TxSignerError,
  TxSubmitError,
  makeReturn,
  makeSubmit,
  makeTxBuilder,
  makeTxSignBuilder,
  ...require("@lucid-evolution/core-types"),
  ...require("@lucid-evolution/core-utils"),
  ...require("@lucid-evolution/plutus"),
  ...require("@lucid-evolution/provider"),
  ...require("@lucid-evolution/sign_data"),
  ...require("@lucid-evolution/utils"),
  ...require("@lucid-evolution/wallet")
});
