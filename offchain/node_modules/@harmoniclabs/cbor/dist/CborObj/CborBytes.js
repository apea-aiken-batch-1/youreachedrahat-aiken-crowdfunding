"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CborBytes = exports.isRawCborBytes = void 0;
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var headerFollowingToAddInfos_1 = require("../utils/headerFollowingToAddInfos.js");
function isRawCborBytes(b) {
    if (typeof b !== "object" || b === null)
        return false;
    var keys = Object.keys(b);
    return (keys.includes("bytes") &&
        (0, uint8array_utils_1.isUint8Array)(b.bytes));
}
exports.isRawCborBytes = isRawCborBytes;
var CborBytes = /** @class */ (function () {
    function CborBytes(bytes, addInfos) {
        this.chunks = bytes;
        this.addInfos = addInfos !== null && addInfos !== void 0 ? addInfos : (0, headerFollowingToAddInfos_1.headerFollowingToAddInfos)(this.bytes.length);
    }
    Object.defineProperty(CborBytes.prototype, "buffer", {
        /** @deprecated use `bytes` instead */
        get: function () { return this.bytes; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CborBytes.prototype, "bytes", {
        /**
         * concatenates all the chunks
         * returns
         **/
        get: function () {
            if (this.chunks instanceof Uint8Array)
                return Uint8Array.prototype.slice.call(this.chunks);
            return uint8array_utils_1.concatUint8Array.apply(void 0, __spreadArray([], __read(this.chunks.map(function (ch) { return ch.bytes; })), false));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CborBytes.prototype, "isDefiniteLength", {
        get: function () {
            return this.chunks instanceof Uint8Array;
        },
        enumerable: false,
        configurable: true
    });
    CborBytes.prototype.toRawObj = function () {
        return {
            bytes: Uint8Array.prototype.slice.call(this.bytes)
        };
    };
    CborBytes.prototype.clone = function () {
        return new CborBytes(this.chunks, this.addInfos);
    };
    return CborBytes;
}());
exports.CborBytes = CborBytes;
function concatBytes(fst, rest) {
    // pre allocate resulting byte
    var result = new Uint8Array(rest.reduce(function (a, b) { return a + b.length; }, fst.length));
    var offset = fst.length;
    result.set(fst, 0); // copy first
    var elem;
    for (var i = 0; i < rest.length; i++) {
        elem = rest[i];
        result.set(elem, offset); // copy ith
        offset += elem.length;
    }
    return result;
}
